- 프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 가상메모리 기법은 `요구 페이징(demand paging) 방식` 과 `요구 세그먼테이션(demand segmentation) 방식으로 구현될 수 있다.

### 1. 요구 페이징

- 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 당장 사용될 페이지만을 올리는 방식이다.
=> 따라서 특정 페이지에 대해 CPU의 요청이 들어운 후에야 해당 페이지를 메모리에 적재한다.
	
- 당장 실행에 필요한 페이지만을 메모리에 적재하기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 올리는 데 소요되는 입출력 오버헤드도 줄어든다.

- 유효-무효 비트(valid-invalid bit)를 두어 각 페이지가 메모리에 존재하는지 표시한다.

- CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아 유효-무효 비트가 무효로 세팅되어 있는 경우를 `페이지 부재(page fault)`가 일어났다고 한다.

#### 1) 요구 페이징의 페이지 부재 처리

- CPU가 무효 페이지에 접근하면 주소 변환을 담당하는 하드웨어인 MMU가 페이지 부재 트랩(page fault trap)을 발생시킨다.
=> CPU의 제어권이 커널모드로 전환되며, 운영체제의 페이지 부재 처리루틴(page fault handler)이 호출되어 페이지 부재를 처리한다.


#### 2) 요구 페이징의 성능

- 성능에 가장 큰 영향을 미치는 요소는 페이지 부재의 발생 빈도이다.
=> 페이지 부재가 일어나면 요청된 페이지를 디스크로부터 메모리로 읽어오는 막대한 오버헤드가 발생하기 때문이다.

### 2. 페이지 교체

- 페이지 부재가 발생하면 요청된 페이지를 디스크에서 메모리로 읽어와야 하는 데, 이때 물리적 메모리에 빈 프레임이 존재하지 않을 수 있다.
=> 이 경우에는 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내 메모리에 빈 공간을 확보하는 작업이 필요하다.
==> 이것을 `페이지 교체(page replacement)`라고 한다.

- 페이지 교체를 할 때는 `교체 알고리즘(replacement algorithm)`을 통해, 페이지 부재율을 최소화하는 것이라고 한다.

#### 1) 최적 페이지 교체

- 페이지 부재율을 최소화하기 위해서는 페이지 교체 시 물리적 메모리에 존재하는 페이지 중 가장 먼 미래에 참조될 페이지를 쫓아내면 된다.
=> 이러한 최적의 알고리즘을 `빌레디의 최적 알고리즘(Belady's optimal algorithm)` 또는 MIN, OPT 등의 이름으로 부른다.

#### 2) 선입선출 알고리즘

- 선입선출(First In First Out:FIFO)알고리즘은 페이지 교체 시 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내쫓는다.

- FIFO 알고리즘에서 메모리를 증가시켰음에도 불구하고 페이지 부재가 오히려 늘어나는 상황을 FIFO의 이상 현상(FIFO anomaly)이라고 한다.

#### 3) LRU 알고리즘

- LRU(Least Recently Used)알고리즘은 페이지 교체 시 가장 오래전에 참조가 이루어진 페이지를 내쫓는다.

#### 4) LFU 알고리즘

- LFU(Least Frequently Used) 알고리즘은 페이지의 참조 횟수로 교체시킬 페이지를 결정한다.
=> 물리적 메모리 내에 존재하는 페이지 중에서 과거에 참조 횟수(reference count)가 가장 적었던 페이지를 쫓아내고 그 자리에 새로 참조될 페이지를 적해한다.

- LFU 알고리즘은 페이지의 참조 횟수를 계산하는 방식에 따라 `Incache-LFU`와 `Perfect-LFU`의 서로 다른 방식으로 구현할 수 있다.
`Incache-LFU` : 페이지가 물리적 메모리에 올라온 후부터의 참조 횟수를 카운트하는 방식
`Perfect-LFU` : 메모리에 올라와 있는지의 여부와 상관없이 그 페이지의 과거 총 참조 횟수를 카운트하는 방식

#### 5) 클럭 알고리즘

- 클럭 알고리즘(clock algorithm)은 하드웨어적인 지원을 통해 알고리즘의 운영 오버헤드를 줄인 방식이다.

- 클럭 알고리즘은 LRU를 근사(approximation)시킨 알고리즘으로 NUR(Not Used Recently) 또는 NRU(Not Recently User) 알고리즘으로도 불린다.

- 오랫동안 참조되지 않은 페이지 중 하나는 교체한다.

- 하드웨어적인 지원으로 동작하기 때문에 LRU에 비해 페이지의 관리가 훨씬 빠르고 효율적으로 이루어진다.
=> 따라서 대부분의 시스템에서 페이지 교체 알고리즘으로 클럭 알고리즘을 채택한다.

### 3. 페이지 프레임의 할당

- 기본적인 할당 알고리즘(allocation algorithm)은 세 가지로 나누어볼 수 있다.
  1. 균등할당(equal allocation) 방식 : 모든 프로세스에게 페이지 프레임을 균일하게 할당하는 방식
  2. 비례할당(proportional allocation) 방식 : 프로세스의 크기에 비례해 페이지 프레임을 할당하는 방식
  3. 우선순위 할당(priority allocation) 방식 : 프로세스의 우선순위에 따라 페이지 프레임을 다르게 할당하는 방식
  
### 4. 전역교체와 지역교체

- 교체할 페이지를 선정할 때, 교체 대상이 될 프레임의 범위를 어떻게 정할지에 따라 교체 방법을 `전역교체(global replacement)`와 `지역교체(local replacement)`로 구분할 수 있다.

- `전역교체` : 
모든 페이지 프레임이 교체 대상이 될 수 있는 방법
프로세스마다 메모리를 할당하는 것이 아니라 전체 메모리를 각 프로세스가 공유해서 사용하고 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방법

- `지역교체` : 
현재 수행 중인 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정할 수 있는 방법
프로세스마다 페이지 프레임을 미리 할당하는 것을 전제로 한다.

### 5. 스레싱

- 최소한의 페이지 프레임을 할당받지 못할 경우 성능상의 심각한 문제가 발생할 수 있다.
=> 집중적으로 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못하면 페이지 부재율이 크게 상승해 CPU 이용률이 급격히 떨어질 수 있기 때문이다.
==> 이와 같은 현상을 `스레싱(thrashing)`이라고 부른다.

- MPD를 적절히 조절해 CPU 이용률을 높이는 동시에 스레싱 발생을 방지하는 방법에는 `워킹셋 알고리즘`과 `페이지 부재 빈도 알고리즘`이 있다.

#### 1) 워킹셋 알고리즘

- 워킹셋 알고리즘은 지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘을 뜻한다.

- 프로세스가 일정 시간 동안 원할히 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합을 워킹셋이라고 정의하고, 프로세스의 워킹셋을 구성하는 페이지들이 한꺼번에 메모리에 올라갈 수 있는 경우에만 그 프로세스에게 메모리를 할당한다.
=> 만약 그렇지 않을 경우에는 프로세스에게 할당된 페이지 프레임들을 모두 반납시킨 후 그 프로세스의 주소 공간 전체를 디스크로 스왑 아웃시킨다.

#### 2) 페이지 부재 빈도 알고리즘

- 페이지 부재 빈도(Page Fault Frequency: PFF)알고리즘은 프로세스의 페이지 부재율을 주기적으로 조사하고 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 동적으로 조절한다.

---
